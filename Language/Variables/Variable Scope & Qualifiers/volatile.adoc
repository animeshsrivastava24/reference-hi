---
title: volatile
categories: [ "चर" ]
subCategories: [ "चर स्कोप और क्वालिफायर" ]
---





= volatile keyword


// अवलोकन अनुभाग शुरू होता है
[#अवलोकन]
--

[float]
=== विवरण
`volatile` एक कीवर्ड है जिसे चर _qualifier_ के रूप में जाना जाता है, यह आमतौर पर चर के डेटाटाइप से पहले उपयोग किया जाता है, जिस तरह से संकलक और बाद के कार्यक्रम चर का इलाज करते हैं।

एक चर `volatile` की घोषणा करना कंपाइलर के लिए एक निर्देश है। कंपाइलर सॉफ्टवेयर है जो आपके C/C++ कोड को मशीन कोड में अनुवाद करता है, जो आर्डुइनो में Atmega चिप के लिए वास्तविक निर्देश हैं।

विशेष रूप से, यह संकलक को रैम से चर को लोड करने के लिए निर्देशित करता है न कि स्टोरेज रजिस्टर से, जो एक अस्थायी मेमोरी लोकेशन है, जहां प्रोग्राम वैरिएबल को संग्रहीत और हेरफेर किया जाता है। कुछ शर्तों के तहत, रजिस्टरों में संग्रहित चर का मान गलत हो सकता है।

एक चर को `volatile` घोषित किया जाना चाहिए जब भी इसका मूल्य कोड अनुभाग के नियंत्रण से परे किसी चीज से बदला जा सकता है जिसमें यह प्रकट होता है, जैसे कि समवर्ती रूप से निष्पादित धागा। आर्डुइनो में, यह होने की संभावना एकमात्र स्थान है जो इंटरप्ट से जुड़े कोड के वर्गों में है, जिसे इंटरप्ट सर्विस रूटीन कहा जाता है।

[float]
=== int or long volatiles
यदि `volatile` चर बाइट से बड़ा है (e.g. a 16 bit int या a 32 bit long), तब माइक्रोकंट्रोलर इसे एक चरण में नहीं पढ़ सकता है, क्योंकि यह एक 8 बिट माइक्रोकंट्रोलर है. इसका मतलब यह है कि जब आपका मुख्य कोड अनुभाग (जैसे आपका लूप) चर के पहले 8 बिट्स को पढ़ता है, तो बाधा पहले से ही दूसरे 8 बिट्स को बदल सकती है. यह चर के लिए यादृच्छिक मूल्यों का उत्पादन करेगा।

उपाय:

जब चर पढ़ा जाता है, तो व्यवधान को अक्षम करने की आवश्यकता होती है, इसलिए वे बिट्स के साथ गड़बड़ नहीं कर सकते हैं, जबकि वे पढ़े जाते हैं।
इसे करने बहुत सारे तरीके हैं:

1. #भाषा# link:../../../functions/interrupts/nointerrupts[noInterrupts]

2. इस्तेमाल करें ATOMIC_BLOCK macro | परमाणु संचालन एकल एमसीयू ऑपरेशन हैं - सबसे छोटी संभव इकाई।


[%hardbreaks]

--
// ओवरव्यू अनुभाग अंत




// कैसे उपयोग करें खंड की शुरुआत
[#कैसेउपयोगकरें]
--

[float]
=== उदाहरण कोड
// वर्णन करें कि उदाहरण कोड क्या है और संबंधित कोड जोड़ें   ►►►►► यह खंड अनिवार्य है ◄◄◄◄◄


[source,arduino]
----
// जब टॉगल पिन में बदलाव होता है, तो टॉगल एलईडी बदल जाता है

int pin = 13;
volatile byte state = LOW;

void setup() {
  pinMode(pin, OUTPUT);
  attachInterrupt(digitalPinToInterrupt(2), blink, CHANGE);
}

void loop() {
  digitalWrite(pin, state);
}

void blink() {
  state = !state;
}
----


[source,arduino]
----
#include <util/atomic.h> // इस लाइब्रेरी में शामिल हैं ATOMIC_BLOCK macro |
volatile int input_from_interrupt;

  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
    // अवरोध के साथ कोड अवरुद्ध (लगातार परमाणु संचालन बाधित नहीं होगा)
    int result = input_from_interrupt;
  }
----



--
// कैसे उपयोग करें खंड का अंत


// यह भी देखे खंड
[#यह_भी_देखे]
--

[float]
=== यह भी देखे

[role="language"]
* #भाषा# link:../../../functions/external-interrupts/attachinterrupt[attachInterrupt]

--
// यह भी देखे खंड का अंत
